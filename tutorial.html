<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Polygon Mesh Processing Library: Tutorial</title>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <!-- Override right arrow icon from navtree.js -->
  <script type="text/javascript">
  var arrowRight = '&#9655;';
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/pmp-library/pmp-library" class="github-corner" title="View source on GitHub">
  <img src="github-corner-right.svg" alt="GitHub link"/>
</a>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="https://www.pmp-library.org"><img alt="Logo" src="pmp-logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Polygon Mesh Processing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('tutorial.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md__home_runner_work_pmp_library_pmp_library_docs_tutorial"></a> This section provides a hands-on tutorial showing the basic usage of PMP. For a thorough introduction to polygon mesh processing we refer to the book of Botsch et al. <a class="el" href="citelist.html#CITEREF_botsch_2010_polygon">[3]</a>.</p>
<h1><a class="anchor" id="autotoc_md60"></a>
Introduction</h1>
<p >In general, a polygonal surface mesh is composed of vertices, edges and faces as well as the incidence relationships between them. <a class="el" href="classpmp_1_1_surface_mesh.html" title="A halfedge data structure for polygonal meshes.">pmp::SurfaceMesh</a> stores the connectivity information based on halfedges, i.e., pairs of directed edges with opposing direction. To be more precise:</p>
<ul>
<li>Each vertex stores an outgoing halfedge.</li>
<li>Each face stores an incident halfedge.</li>
<li>Each halfedge stores its incident face, its target vertex, and its previous and next halfedges within the face.</li>
</ul>
<p >The halfedge connectivity is illustrated in the figure below:</p>
<p ><img src="halfedge-connectivity.svg" alt="" style="pointer-events: none;" class="inline" title="Halfedge connectivity."/></p>
<p >In the following sections we describe the basic usage of <a class="el" href="classpmp_1_1_surface_mesh.html" title="A halfedge data structure for polygonal meshes.">pmp::SurfaceMesh</a> by means of simple example programs and code excerpts.</p>
<h1><a class="anchor" id="autotoc_md61"></a>
Basics</h1>
<p >The very basic usage of <a class="el" href="classpmp_1_1_surface_mesh.html" title="A halfedge data structure for polygonal meshes.">pmp::SurfaceMesh</a> is demonstrated in the example below. The program first instantiates a <a class="el" href="classpmp_1_1_surface_mesh.html" title="A halfedge data structure for polygonal meshes.">pmp::SurfaceMesh</a> object as well as four vertex handles. These handles, as well as the handles for the other mesh entities <code>Halfedge</code>, <code>Edge</code> and <code>Face</code> basically indices. Four vertices are added to the mesh, as well as four triangular faces composing a tetrahedron. Finally, the number of vertices, edges, and faces is printed to standard output.</p>
<div class="fragment"><div class="line"><span class="comment">// instantiate a SurfaceMesh object</span></div>
<div class="line">SurfaceMesh mesh;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// add 4 vertices</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v0 = mesh.add_vertex(<a class="code hl_typedef" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a>(0, 0, 0));</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v1 = mesh.add_vertex(<a class="code hl_typedef" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a>(1, 0, 0));</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v2 = mesh.add_vertex(<a class="code hl_typedef" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a>(0, 1, 0));</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v3 = mesh.add_vertex(<a class="code hl_typedef" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a>(0, 0, 1));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// add 4 triangular faces</span></div>
<div class="line">mesh.add_triangle(v0, v1, v3);</div>
<div class="line">mesh.add_triangle(v1, v2, v3);</div>
<div class="line">mesh.add_triangle(v2, v0, v3);</div>
<div class="line">mesh.add_triangle(v0, v2, v1);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;vertices: &quot;</span> &lt;&lt; mesh.n_vertices() &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;edges: &quot;</span> &lt;&lt; mesh.n_edges() &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;faces: &quot;</span> &lt;&lt; mesh.n_faces() &lt;&lt; std::endl;</div>
<div class="ttc" id="agroup__core_html_ga4fc38b084567aed726be776958bfcc78"><div class="ttname"><a href="group__core.html#ga4fc38b084567aed726be776958bfcc78">pmp::Point</a></div><div class="ttdeci">Vector&lt; Scalar, 3 &gt; Point</div><div class="ttdoc">Point type.</div><div class="ttdef"><b>Definition:</b> Types.h:39</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md62"></a>
Iterators and Circulators</h1>
<p >In order to sequentially access mesh entities <a class="el" href="classpmp_1_1_surface_mesh.html" title="A halfedge data structure for polygonal meshes.">pmp::SurfaceMesh</a> provides iterators for each entity type:</p>
<ol type="1">
<li><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_iterator.html" title="An iterator class to iterate linearly over all vertices.">pmp::SurfaceMesh::VertexIterator</a></li>
<li><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_iterator.html" title="this class iterates linearly over all halfedges">pmp::SurfaceMesh::HalfedgeIterator</a></li>
<li><a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_iterator.html" title="this class iterates linearly over all edges">pmp::SurfaceMesh::EdgeIterator</a></li>
<li><a class="el" href="classpmp_1_1_surface_mesh_1_1_face_iterator.html" title="this class iterates linearly over all faces">pmp::SurfaceMesh::FaceIterator</a></li>
</ol>
<p >Similar to iterators, <a class="el" href="classpmp_1_1_surface_mesh.html" title="A halfedge data structure for polygonal meshes.">pmp::SurfaceMesh</a> also provides circulators for the ordered enumeration of all incident vertices, halfedges, or faces around a given face or vertex. The example below demonstrates the use of iterators and circulators for computing the mean valence of a mesh.</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> mean_valence = 0.0f;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// loop over all vertices</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> v : mesh.vertices())</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// sum up vertex valences</span></div>
<div class="line">    mean_valence += mesh.valence(v);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">mean_valence /= mesh.n_vertices();</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;mean valence: &quot;</span> &lt;&lt; mean_valence &lt;&lt; std::endl;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md63"></a>
Dynamic Properties</h1>
<p >Attaching additional attributes to mesh entities is important for many applications. <a class="el" href="classpmp_1_1_surface_mesh.html" title="A halfedge data structure for polygonal meshes.">pmp::SurfaceMesh</a> supports properties by means of synchronized arrays that can be (de-)allocated dynamically at run-time. Property arrays are also used internally, e.g., to store vertex coordinates. The example program below shows how to access vertex coordinates through the pre-defined point property.</p>
<div class="fragment"><div class="line"><span class="comment">// get pre-defined property storing vertex positions</span></div>
<div class="line"><span class="keyword">auto</span> points = mesh.get_vertex_property&lt;<a class="code hl_typedef" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a>&gt;(<span class="stringliteral">&quot;v:point&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> p(0, 0, 0);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> v : mesh.vertices())</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// access point property like an array</span></div>
<div class="line">    p += points[v];</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">p /= mesh.n_vertices();</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;barycenter: &quot;</span> &lt;&lt; p &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >The dynamic (de-)allocation of properties at run-time is managed by a set of four different functions.</p>
<ul>
<li><p class="startli">Add a new property of a specific type for a given entity. Example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> vertex_weights = mesh.add_vertex_property&lt;<a class="code hl_typedef" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&gt;(<span class="stringliteral">&quot;v:weight&quot;</span>);</div>
<div class="ttc" id="agroup__core_html_ga4be45d931ceeeea4be9f14978f30e498"><div class="ttname"><a href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">pmp::Scalar</a></div><div class="ttdeci">float Scalar</div><div class="ttdoc">Scalar type.</div><div class="ttdef"><b>Definition:</b> Types.h:35</div></div>
</div><!-- fragment --></li>
<li><p class="startli">Get a handle to an existing property. Example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> points = mesh.get_vertex_property&lt;<a class="code hl_typedef" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a>&gt;(<span class="stringliteral">&quot;v:point&quot;</span>);</div>
</div><!-- fragment --></li>
<li><p class="startli">Get or add: Return a handle to an existing property if a property of the same type and name exists. If there is no such property, a new one is allocated and its handle is returned. Example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> edge_weights = mesh.edge_property&lt;<a class="code hl_typedef" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&gt;(<span class="stringliteral">&quot;e:weight&quot;</span>);</div>
</div><!-- fragment --></li>
<li><p class="startli">Remove a property given its handle:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> face_colors = mesh.face_property&lt;<a class="code hl_typedef" href="group__core.html#ga2a0880e8471e0ba1af6ed132f0ba97a7">Color</a>&gt;(<span class="stringliteral">&quot;f:color&quot;</span>);</div>
<div class="line">mesh.remove_face_property(face_colors);</div>
<div class="ttc" id="agroup__core_html_ga2a0880e8471e0ba1af6ed132f0ba97a7"><div class="ttname"><a href="group__core.html#ga2a0880e8471e0ba1af6ed132f0ba97a7">pmp::Color</a></div><div class="ttdeci">Vector&lt; Scalar, 3 &gt; Color</div><div class="ttdoc">Color type.</div><div class="ttdef"><b>Definition:</b> Types.h:46</div></div>
</div><!-- fragment --></li>
</ul>
<p >Functions that allocate a new property take an optional default value for the property as a second argument. Example:</p>
<div class="fragment"><div class="line">mesh.face_property&lt;<a class="code hl_typedef" href="group__core.html#ga2a0880e8471e0ba1af6ed132f0ba97a7">Color</a>&gt;(<span class="stringliteral">&quot;f:color&quot;</span>, <a class="code hl_typedef" href="group__core.html#ga2a0880e8471e0ba1af6ed132f0ba97a7">Color</a>(1.0, 0.0, 0.0));</div>
</div><!-- fragment --><p >The code excerpt below demonstrates how to allocate, use and remove a custom edge property.</p>
<div class="fragment"><div class="line"><span class="comment">// get pre-defined point property</span></div>
<div class="line"><span class="keyword">auto</span> points = mesh.get_vertex_property&lt;<a class="code hl_typedef" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a>&gt;(<span class="stringliteral">&quot;v:point&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// add new property storing a point per edge</span></div>
<div class="line"><span class="keyword">auto</span> edge_points = mesh.add_edge_property&lt;<a class="code hl_typedef" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a>&gt;(<span class="stringliteral">&quot;e:point&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// loop over all edges</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> e : mesh.edges())</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// compute midpoint</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> p0 = points[mesh.vertex(e, 0)];</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> p1 = points[mesh.vertex(e, 1)];</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> midpoint = (p0 + p1 ) * <a class="code hl_typedef" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>(0.5);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// access edge property like an array</span></div>
<div class="line">    edge_points[e] = midpoint;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// remove property to free memory</span></div>
<div class="line">mesh.remove_edge_property(edge_points);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md64"></a>
Connectivity Queries</h1>
<p >Commonly used connectivity queries such as retrieving the next halfedge or the target vertex of an halfedge are illustrated below.</p>
<div class="fragment"><div class="line">Halfedge h;</div>
<div class="line"><span class="keyword">auto</span> h0 = mesh.next_halfedge(h);</div>
<div class="line"><span class="keyword">auto</span> h1 = mesh.prev_halfedge(h);</div>
<div class="line"><span class="keyword">auto</span> h2 = mesh.opposite_halfedge(h);</div>
<div class="line"><span class="keyword">auto</span> f  = mesh.face(h);</div>
<div class="line"><span class="keyword">auto</span> v0 = mesh.from_vertex(h);</div>
<div class="line"><span class="keyword">auto</span> v1 = mesh.to_vertex(h);</div>
</div><!-- fragment --><p ><img src="connectivity-queries.svg" alt="" style="pointer-events: none;" class="inline" title="Connectivity queries"/></p>
<h1><a class="anchor" id="autotoc_md65"></a>
Topological Operations</h1>
<p ><a class="el" href="classpmp_1_1_surface_mesh.html" title="A halfedge data structure for polygonal meshes.">pmp::SurfaceMesh</a> also offers higher-level topological operations, such as performing edge flips, edge splits, face splits, or halfedge collapses. The figure below illustrates some of these operations.</p>
<p ><img src="topology-changes.png" alt="" class="inline" title="High-level operations changing the topology."/></p>
<p >The corresponding member functions and their syntax is demonstrated in the pseudo-code below.</p>
<div class="fragment"><div class="line">Vertex   v;</div>
<div class="line">Edge     e;</div>
<div class="line">Halfedge h;</div>
<div class="line">Face     f;</div>
<div class="line"> </div>
<div class="line">mesh.split(f, v);</div>
<div class="line">mesh.split(e, v);</div>
<div class="line">mesh.flip(e);</div>
<div class="line">mesh.collapse(h);</div>
</div><!-- fragment --><p >When entities are removed from the mesh due to topological changes, the member function <a class="el" href="classpmp_1_1_surface_mesh.html#a18ccfc2210e9d09621859d6f95381aaf" title="remove deleted elements">pmp::SurfaceMesh::garbage_collection()</a> has to be called in order to ensure the consistency of the data structure.</p>
<h1><a class="anchor" id="autotoc_md66"></a>
File I/O</h1>
<p >All I/O operations are handled by the <a class="el" href="group__io.html#ga2bcb6c26485632205f195d41d3aa66d6" title="Read into mesh from file.">pmp::read()</a> and <a class="el" href="group__io.html#gad296359779629df88b6f3c4db874536a" title="Write mesh to file controlled by flags.">pmp::write()</a> functions. They take a mesh, a file path, and optional <a class="el" href="structpmp_1_1_i_o_flags.html" title="Flags to control reading and writing.">pmp::IOFlags</a> as an argument.</p>
<p >We currently support reading and writing several standard file formats: OFF, OBJ, STL. See the reference documentation for the <a class="el" href="group__io.html#ga2bcb6c26485632205f195d41d3aa66d6" title="Read into mesh from file.">pmp::read()</a> and <a class="el" href="group__io.html#gad296359779629df88b6f3c4db874536a" title="Write mesh to file controlled by flags.">pmp::write()</a> functions for details on which format supports reading / writing which type of data.</p>
<p >A simple example reading and writing a mesh is shown below.</p>
<div class="fragment"><div class="line"><span class="comment">// instantiate a SurfaceMesh object</span></div>
<div class="line">SurfaceMesh mesh;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// read a mesh specified as the first command line argument</span></div>
<div class="line"><span class="keywordflow">if</span> (argc &gt; 1)</div>
<div class="line">    <a class="code hl_function" href="group__io.html#ga2bcb6c26485632205f195d41d3aa66d6">read</a>(mesh, argv[1]);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// do something with the mesh</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// write the mesh to the file specified as second argument</span></div>
<div class="line"><span class="keywordflow">if</span> (argc &gt; 2)</div>
<div class="line">    <a class="code hl_function" href="group__io.html#gad296359779629df88b6f3c4db874536a">write</a>(mesh, argv[2]);</div>
<div class="ttc" id="agroup__io_html_ga2bcb6c26485632205f195d41d3aa66d6"><div class="ttname"><a href="group__io.html#ga2bcb6c26485632205f195d41d3aa66d6">pmp::read</a></div><div class="ttdeci">void read(SurfaceMesh &amp;mesh, const std::filesystem::path &amp;file)</div><div class="ttdoc">Read into mesh from file.</div><div class="ttdef"><b>Definition:</b> io.cpp:17</div></div>
<div class="ttc" id="agroup__io_html_gad296359779629df88b6f3c4db874536a"><div class="ttname"><a href="group__io.html#gad296359779629df88b6f3c4db874536a">pmp::write</a></div><div class="ttdeci">void write(const SurfaceMesh &amp;mesh, const std::filesystem::path &amp;file, const IOFlags &amp;flags)</div><div class="ttdoc">Write mesh to file controlled by flags.</div><div class="ttdef"><b>Definition:</b> io.cpp:38</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md67"></a>
Eigen Interoperability</h1>
<p >The pmp-library supports some level of interoperability with Eigen. The <a class="el" href="classpmp_1_1_matrix.html" title="Base class for MxN matrix.">pmp::Matrix</a> and <a class="el" href="group__core.html#gaeed533a3d251ad147a71b68b58ed9cbb" title="template specialization for Vector as Nx1 matrix">pmp::Vector</a> classes can be constructed/assigned from Eigen matrix/vector types. In addition, it possible to cast the <a class="el" href="classpmp_1_1_matrix.html" title="Base class for MxN matrix.">pmp::Matrix</a> and <a class="el" href="group__core.html#gaeed533a3d251ad147a71b68b58ed9cbb" title="template specialization for Vector as Nx1 matrix">pmp::Vector</a> classes to Eigen.</p>
<p >Example for construction:</p>
<div class="fragment"><div class="line"><span class="comment">// construction from Eigen</span></div>
<div class="line">Eigen::Vector3d eigen_vector(1.0, 2.0, 3.0);</div>
<div class="line"><a class="code hl_class" href="classpmp_1_1_matrix.html">pmp::dvec3</a> pmp_vector = eigen_vector;</div>
<div class="ttc" id="aclasspmp_1_1_matrix_html"><div class="ttname"><a href="classpmp_1_1_matrix.html">pmp::Matrix</a></div><div class="ttdoc">Base class for MxN matrix.</div><div class="ttdef"><b>Definition:</b> MatVec.h:27</div></div>
</div><!-- fragment --><p >Example for assignment:</p>
<div class="fragment"><div class="line"><span class="comment">// assignment from Eigen</span></div>
<div class="line">Eigen::Vector3d eigen_vector(1.0, 2.0, 3.0);</div>
<div class="line"><a class="code hl_class" href="classpmp_1_1_matrix.html">pmp::dvec3</a> pmp_vector;</div>
<div class="line">pmp_vector = eigen_vector;</div>
</div><!-- fragment --><p >Example for cast:</p>
<div class="fragment"><div class="line"><span class="comment">// cast to Eigen</span></div>
<div class="line"><a class="code hl_class" href="classpmp_1_1_matrix.html">pmp::vec3</a> pmp_vector(1.0, 2.0, 3.0);</div>
<div class="line">Eigen::Vector3f eigen_vector = <span class="keyword">static_cast&lt;</span>Eigen::Vector3f<span class="keyword">&gt;</span>(pmp_vector);</div>
</div><!-- fragment --><p >See the reference documentation for <a class="el" href="classpmp_1_1_matrix.html" title="Base class for MxN matrix.">pmp::Matrix</a> and <a class="el" href="group__core.html#gaeed533a3d251ad147a71b68b58ed9cbb" title="template specialization for Vector as Nx1 matrix">pmp::Vector</a> for more details. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath">
  <address>
    Copyright © 2011-2023 the Polygon Mesh Processing Library developers.
  </address>
</div>
</body>
</html>